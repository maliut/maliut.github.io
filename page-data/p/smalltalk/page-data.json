{"componentChunkName":"component---src-templates-post-js","path":"/p/smalltalk/","result":{"data":{"markdownRemark":{"id":"639914a2-751b-54d1-964d-1e8d1aac1ea4","excerpt":"旧笔记补档，原来是为 2017-10-06 线下 MAP 活动做的笔记 2018-08-02 第一版 2020-08-06 第二版 前言 为什么要学习 Smalltalk？Smalltalk…","html":"<blockquote>\n<p>旧笔记补档，原来是为 2017-10-06 线下 MAP 活动做的笔记</p>\n<p>2018-08-02 第一版</p>\n<p>2020-08-06 第二版</p>\n</blockquote>\n<!--more-->\n<h2>前言</h2>\n<p>为什么要学习 Smalltalk？Smalltalk 是一门历史悠久的语言，虽然如今我们几乎没有机会再去使用它，但它的不少开创性的理念，仍影响了许多现代的编程语言和思想。尤其是如今主流的面向对象语言 C++ 和 Java，它们本身并不是纯粹的、适合教学的「面向对象」语言，导致初学者往往陷入一些细枝末节导致理解困难。而学习 Smalltalk，我们能从语言的演进中更精准地理解一些重要概念的沿革，也可以从打破固化思维，得到一些新的编程灵感。</p>\n<p>如今中文互联网上关于 Smalltalk 的资料相对较少，且大多比较老，或是直接机翻的外文博客。大概三年前我出于个人爱好对 Smalltalk 进行了一些入门了解，并和小伙伴们做了线下分享。这回也是把当时的一些笔记整理后发到网上，算是添砖加瓦吧。</p>\n<p>本文脉络主要参考了 <a href=\"http://www.eli.sdsu.edu/courses/spring01/cs635/readingSmalltalk.pdf\">I Can Read C++ and Java But I Can’t Read Smalltalk</a> 以及 <a href=\"http://www.vaikan.com/why-i-love-smalltalk/\">Why I love smalltalk</a> 。不过并不是照搬，而是加入了一些个人的理解<del>夹带私货</del>。希望我的引申能够使读者更容易地理解这一有趣的语言。</p>\n<h2>基础语法</h2>\n<p>现代编程语言的语法往往大同小异，但 Smalltalk 和如今的语言语法差距还是不小，这也是大多数人第一眼看到代码觉得难以理解的原因之一（想看到实际的代码例子可以<a href=\"https://github.com/gnu-smalltalk/smalltalk/tree/master/examples\">点击这里</a>）。但虽然写法不同，编程语言的常规要素还是大差不差的，我们先浮光掠影地看一下这些基础语法，便能够读懂大部分的代码内容。</p>\n<ul>\n<li>注释：用双引号包围。 e.g. <code class=\"language-text\">&quot;这是注释&quot;</code></li>\n<li>字符串：用单引号包围。 e.g. <code class=\"language-text\">&#39;这是一个字符串&#39;</code></li>\n<li>单个字符：e.g. <code class=\"language-text\">$c</code></li>\n<li>符号（Symbol）：e.g. <code class=\"language-text\">#thisIsASymbol</code>\n大家也许对符号这个概念比较陌生。简单来说，如果两个符号的值一样，那么它们在内存中也是相同的对象。后面的 Ruby 等语言也继承了这一设计。</li>\n<li>变量声明：e.g. <code class=\"language-text\">| a |</code> ，也可以一次声明多个：<code class=\"language-text\">| a b c |</code></li>\n<li>赋值语句：e.g. <code class=\"language-text\">a := 5</code></li>\n<li>相等性与同一性：相等性使用 <code class=\"language-text\">=</code> ，相当于 Java 中的 <code class=\"language-text\">equals()</code> 。同一性使用 <code class=\"language-text\">==</code> ，即判断内存地址相同。</li>\n<li>返回语句：<code class=\"language-text\">^ a</code> 即其他语言中的 <code class=\"language-text\">return a</code> 。</li>\n<li>\n<p>级联：不同于大多数语言，Smalltalk 使用 <code class=\"language-text\">.</code> 表示语句的末尾，而 <code class=\"language-text\">;</code> 用于实现级联的功能。所谓级联，就是指可以连续在同一个对象上调用方法，而不必每次都重复写出这个对象。举个例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"smalltalk\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-smalltalk line-numbers\"><code class=\"language-smalltalk\"><span class=\"token temporary-variables\"><span class=\"token punctuation\">|</span> <span class=\"token variable\">p</span> <span class=\"token punctuation\">|</span></span> \np <span class=\"token operator\">:=</span> Client <span class=\"token keyword\">new</span>    \nname<span class=\"token punctuation\">:</span> <span class=\"token string\">'Jack'</span><span class=\"token punctuation\">;</span>     \nage<span class=\"token punctuation\">:</span> <span class=\"token number\">32</span><span class=\"token punctuation\">;</span>     \naddress<span class=\"token punctuation\">:</span> <span class=\"token string\">'Earth'</span><span class=\"token punctuation\">.</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>现代语言中 Dart 就延续了类似的设定。不过我个人倒是觉得这个语法用处不大，毕竟用 Builder 模式也可以解决问题，而无需定义新的语法。</p>\n</li>\n</ul>\n<h2>方法与类</h2>\n<p>来看一个 Smalltalk 中方法定义和调用的例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"smalltalk\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-smalltalk line-numbers\"><code class=\"language-smalltalk\"><span class=\"token comment\">\"定义一个方法：使物体围绕某个轴旋转一定角度\"</span>\nrotateBy<span class=\"token punctuation\">:</span> angle around<span class=\"token punctuation\">:</span> vector\n  <span class=\"token temporary-variables\"><span class=\"token punctuation\">|</span> <span class=\"token variable\">result</span> <span class=\"token punctuation\">|</span></span>\n  result <span class=\"token operator\">:=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>省略具体内容<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>\n  <span class=\"token operator\">^</span>result\n\n<span class=\"token comment\">\"调用这个方法\"</span>\nt rotateBy<span class=\"token punctuation\">:</span> a around<span class=\"token punctuation\">:</span> v<span class=\"token punctuation\">.</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>相信除了 Objective-C 程序员，大家初看到都会觉得这样的方法签名有点奇怪。不过我们可以基于主流语言的语法，来看看一个方法是以何种逻辑演化成 Smalltalk 的样子的。</p>\n<p>先从我们熟悉的形式开始：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">t-&gt;rotate(a, v);  // In C++\nt.rotate(a, v);   // In Java</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>省略掉一些不影响语义的符号：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">t rotate(a, v);    // 省略掉 .\nt rotate a, v;     // 省略括号</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>然后我们发现参数的含义不太清晰，可以给每个参数前面加一个词语来使含义更加精确：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">t rotate by a around v;</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>但是这样的话，哪个词语是前缀，哪个是参数就不太能分得清。因此我们给前缀加个冒号来区分：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">t rotate by: a around: v;</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>最后，都这样了，方法名字本身也没必要单列出来，可以直接和参数前缀合并起来，就成了 Smalltalk 现在的样子：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">t rotateBy: a around: v; </code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<br>\n让我们再来看一个复杂点的例子：\n``` smalltalk\na negative | (b between: c and: d)\n  ifTrue: [a := c negated]\n```\n它相当于其他语言中的：\n``` java\nif (a < 0 || (c < b && b < d)) {\n    a = -c;\n}\n```\n细品这个例子，我们可以看到很多有意思的地方。首先来看这个 `c negated` 。有人会说，直接写个 `-c` 不就完了，为什么要搞这么臃肿。表面看上去，只是写法的不同，但其实它代表着理念的不同。`-c` 代表对 `c` 这个数字做了一次数学运算，而 `c negated` 代表的是在 `c` 这个对象上调用 `negated` 方法，然后用这个方法的返回值去做下一步的操作。\n<p>这里体现了 Smalltalk 的核心概念之一：<strong>一切皆是对象</strong>。对比另一门同样号称一切皆是对象的语言 Java，在 Java 中你永远不可能写出 <code class=\"language-text\">5.negated()</code> 这种代码，而所谓的基本类型、包装类型让多少初学者陷入困惑，又让多少面试官洋洋得意。但在 Smalltalk 里，对象的概念才是真正贯穿始终，保持同一性，也避免了这种困惑。</p>\n<p>其次我们来讨论 Smalltalk 中另一个重要概念：<strong>消息</strong>。在前文中我们看到了如何调用方法。但在 Smalltalk 中并没有调用方法的概念，而是叫做<strong>给对象发送消息</strong>。例如 <code class=\"language-text\">c negated</code> 用 Smalltalk 的话说，就是给对象 <code class=\"language-text\">c</code> 发送了一个名为 <code class=\"language-text\">negated</code> 的消息。</p>\n<p>在 Smalltalk 中有三种消息，它们在上面的例子中都能体现：</p>\n<ul>\n<li>一元（unary）消息：可以理解为一个无参方法，例如上面的 <code class=\"language-text\">negated</code> 消息。</li>\n<li>二元（binary）消息：就是常用的一组计算符号，比如四则运算符还有上面的 <code class=\"language-text\">|</code> 之类的。不过需要注意的是它的本质还是发送消息而不是直接运算，因此没有运算符优先级的概念。<code class=\"language-text\">+</code> 和 <code class=\"language-text\">*</code> 在 Smalltalk 中的优先级是相等的。</li>\n<li>Keyword 消息：就是普通的有参方法，在 Smalltalk 中就是每个参数以冒号连接来表示，比如上面的 <code class=\"language-text\">rotateBy:around:</code> 还有 <code class=\"language-text\">between:and:</code> 。这样的消息在 Smalltalk 中被称为 <strong>keyword</strong> 。</li>\n</ul>\n<p>有人可能会说，把方法调用说成是发送消息，但运行的效果是一样的，这不是换汤不换药吗？话是这么说，但用于描述的词汇的不同也会带来思维方式的不同。相比于「方法调用」，「发送消息」这个说法会显得更加泛用一些，也可以带来一些更本质的思考。</p>\n<p>举个例子，如果我们调用一个不存在的方法，那自然会报错。但如果给一个对象发送一个它不认识的消息，那非得报错吗？我大不了不处理不就行了。甚至，能不能在遇到这种情况时，有个兜底的逻辑统一处理下？—— Ruby 的 <code class=\"language-text\">method_missing</code> 了解一下。</p>\n<p>再比如说当我们学习面向对象时提到的所谓「三大特征」：继承、封装、多态。继承本质上是面向对象语言中实现代码重用的一种手段，但现在「组合优于继承」早已成为共识。封装是为了隐藏底层或内部的实现细节，也并不是面向对象独有的概念。而多态解释起来最为复杂，我们往往需要定义一个父类，并让两个不同的子类 override 父类的同一个方法，并编写不同的实现，来说明多态性。但是如果用发送消息的思路来解释就很简单了。给两个不同的对象发送同一个消息，这两个对象会做出不同的反应，这不是理所当然的事情吗？压根和类、继承之类的概念没关系。</p>\n<p>对面向对象这一概念的误读影响了很多人。记得几年前见过一个问题，问的是「JavaScript 是一门面向对象的语言吗？」，下面的回答也是众说纷纭。而之所以大家会有争议，是因为 JavaScript 中并没有类的概念，取而代之的是原型的概念，搞的很多人一下子就混乱了。后来 ES6 的标准里增加了 class 的语法糖，我就再也没有见过有人提这个问题了。</p>\n<p>希望读者通过学习 Smalltalk 这门面向对象的鼻祖级语言，理解一切皆是对象以及对象间通过发送消息来通信这两个核心理念，减少一些对面向对象概念的误读。</p>\n<p>在理解了 Smalltalk 的设计理念之后，我们再来看一下怎么声明一个类：</p>\n<div class=\"gatsby-highlight\" data-language=\"smalltalk\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-smalltalk line-numbers\"><code class=\"language-smalltalk\">Object subclass<span class=\"token punctuation\">:</span> <span class=\"token symbol\">#MyClass</span>      \n  instanceVariableNames<span class=\"token punctuation\">:</span> <span class=\"token string\">''</span>      \n  classVariableNames<span class=\"token punctuation\">:</span> <span class=\"token string\">''</span>      \n  poolDictionaries<span class=\"token punctuation\">:</span> <span class=\"token string\">''</span>      \n  category<span class=\"token punctuation\">:</span> <span class=\"token string\">'Pupeno'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>大部分编程语言都会使用 <code class=\"language-text\">class</code> 关键字声明一个类，并用 <code class=\"language-text\">extends</code> 或类似的关键字来声明继承关系。而 Smalltalk 则另辟蹊径。让我们来看看它的逻辑：首先，由于一切皆是对象，因此 <code class=\"language-text\">Object</code> 类也是一个对象；其次，<code class=\"language-text\">Object</code> 类可以接收名为 <code class=\"language-text\">subclass:</code> 的消息，创建一个新的对象作为它的子类。无需再引入任何特殊的语法，仅用语言本身的两个核心理念，就十分自洽地把类的概念创建了出来。</p>\n<p>不仅仅是定义类，还有我们常用的分支、循环语句等，在 Smalltalk 中都可以通过发送消息的形式来实现，而无需定义额外的诸如 <code class=\"language-text\">if</code>、<code class=\"language-text\">while</code> 等关键字。这或许就是 Smalltalk 把类似 <code class=\"language-text\">subclass:</code> 之类的带参消息都称作 keyword 的原因。它们完全可以替代其他语言中各种关键字的职能。</p>\n<h2>代码块</h2>\n<p>继续回到上一节的例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"smalltalk\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-smalltalk line-numbers\"><code class=\"language-smalltalk\">a negative <span class=\"token operator\">|</span> <span class=\"token punctuation\">(</span>b between<span class=\"token punctuation\">:</span> c and<span class=\"token punctuation\">:</span> d<span class=\"token punctuation\">)</span>\n  ifTrue<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>a <span class=\"token operator\">:=</span> c negated<span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>关注这个 <code class=\"language-text\">[a := c negated]</code> 。这里由中括号包围的部分，大家或许会以为就像是 C++/Java 里跟在 <code class=\"language-text\">if</code> 语句后面的大括号——对，但不全对。在 Smalltalk 中它被称为代码块，是语言中的一等公民，可以放在一个变量里面，自由地控制它的调用时机，也可以把它像参数一样传递。如果你熟悉 JavaScript 就一定不会感到陌生。做个简单对比：</p>\n<div class=\"gatsby-highlight\" data-language=\"smalltalk\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-smalltalk line-numbers\"><code class=\"language-smalltalk\"><span class=\"token comment\">\"in Smalltalk\"</span>\na <span class=\"token operator\">:=</span> <span class=\"token punctuation\">[</span><span class=\"token block-arguments\"><span class=\"token variable\">:x</span> <span class=\"token punctuation\">|</span></span> x <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>       <span class=\"token comment\">\"将一个代码块赋值给 a\"</span>\n<span class=\"token punctuation\">(</span>a value<span class=\"token punctuation\">:</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span>           <span class=\"token comment\">\"运行这个代码块并传入参数 10\"</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token comment\">// in Javascript</span>\n<span class=\"token keyword\">let</span> <span class=\"token function-variable function\">a</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> x <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>其实这就是匿名函数的概念，了解过函数式编程概念的朋友们看了一定不会陌生。函数式编程的理念近年来也重回大众视野，即使是 Java 也在 1.8 中加入了相关的特性。可以看到虽说 Smalltalk 的特点是纯粹的面向对象语言，但论函数式编程的能力也完全不输现代的主流语言们。</p>\n<h2>控制流</h2>\n<p>结合 Smalltalk 对象间发送消息的思想和代码块的能力，我们将变得无所不能。上文中提到 Smalltalk 无需额外的关键字就能实现 <code class=\"language-text\">if</code> 和 <code class=\"language-text\">while</code> 等的功能。在最后一节中就让我们具体地看一下如何利用这些能力来实现 <code class=\"language-text\">if</code> 的功能吧。这也是我当初学习 Smalltalk 时最喜欢的一个例子。</p>\n<p>首先，我们需要定义出 <code class=\"language-text\">true</code> 和 <code class=\"language-text\">false</code> 这两个常量：</p>\n<p>先定义出 <code class=\"language-text\">PBoolean</code> 类，然后将 <code class=\"language-text\">PTrue</code> 和 <code class=\"language-text\">PFalse</code> 作为它的子类。<code class=\"language-text\">PTrue</code> 类的实例就可以认为是 <code class=\"language-text\">true</code>，<code class=\"language-text\">false</code> 也是同理。</p>\n<div class=\"gatsby-highlight\" data-language=\"smalltalk\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-smalltalk line-numbers\"><code class=\"language-smalltalk\">Object subclass<span class=\"token punctuation\">:</span> <span class=\"token symbol\">#PBoolean</span>      \n  instanceVariableNames<span class=\"token punctuation\">:</span> <span class=\"token string\">''</span>      \n  classVariableNames<span class=\"token punctuation\">:</span> <span class=\"token string\">''</span>      \n  poolDictionaries<span class=\"token punctuation\">:</span> <span class=\"token string\">''</span>      \n  category<span class=\"token punctuation\">:</span> <span class=\"token string\">'Pupeno'</span>\nPBoolean subclass<span class=\"token punctuation\">:</span> <span class=\"token symbol\">#PTrue</span>      \n  instanceVariableNames<span class=\"token punctuation\">:</span> <span class=\"token string\">''</span>      \n  classVariableNames<span class=\"token punctuation\">:</span> <span class=\"token string\">''</span>      \n  poolDictionaries<span class=\"token punctuation\">:</span> <span class=\"token string\">''</span>      \n  category<span class=\"token punctuation\">:</span> <span class=\"token string\">'Pupeno'</span>\nPBoolean subclass<span class=\"token punctuation\">:</span> <span class=\"token symbol\">#PFalse</span>      \n  instanceVariableNames<span class=\"token punctuation\">:</span> <span class=\"token string\">''</span>      \n  classVariableNames<span class=\"token punctuation\">:</span> <span class=\"token string\">''</span>      \n  poolDictionaries<span class=\"token punctuation\">:</span> <span class=\"token string\">''</span>      \n  category<span class=\"token punctuation\">:</span> <span class=\"token string\">'Pupeno'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>其次，我们定义 <code class=\"language-text\">ifTrue:else:</code> 消息。它接受两个代码块作为参数。当 <code class=\"language-text\">PTrue</code> 类的实例接收到消息时，它执行 <code class=\"language-text\">ifTrue:</code> 携带的代码块，忽略 <code class=\"language-text\">else:</code> 携带的代码块。反之亦然。</p>\n<div class=\"gatsby-highlight\" data-language=\"smalltalk\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-smalltalk line-numbers\"><code class=\"language-smalltalk\"><span class=\"token comment\">\"PTrue 中定义\"</span>\nifTrue<span class=\"token punctuation\">:</span> do else<span class=\"token punctuation\">:</span> notdo  \n  <span class=\"token operator\">^</span> do value\n  \n<span class=\"token comment\">\"PFalse 中定义\"</span>\nifTrue<span class=\"token punctuation\">:</span> notdo else<span class=\"token punctuation\">:</span> do  \n  <span class=\"token operator\">^</span> do value</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>再次，我们定义一个 <code class=\"language-text\">MyClass</code> 类，它可以接受 <code class=\"language-text\">equals:</code> 消息判断两个对象是否相等。为了方便起见，我们永远返回 <code class=\"language-text\">true</code> 。实际情况下可以自行实现其业务逻辑。</p>\n<div class=\"gatsby-highlight\" data-language=\"smalltalk\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-smalltalk line-numbers\"><code class=\"language-smalltalk\">equals<span class=\"token punctuation\">:</span> other  \n  <span class=\"token operator\">^</span> PTrue <span class=\"token keyword\">new</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>最后，我们就可以愉快地使用 if-else 了：</p>\n<div class=\"gatsby-highlight\" data-language=\"smalltalk\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-smalltalk line-numbers\"><code class=\"language-smalltalk\">m1 <span class=\"token operator\">:=</span> MyClass <span class=\"token keyword\">new</span><span class=\"token punctuation\">.</span>\nm2 <span class=\"token operator\">:=</span> MyClass <span class=\"token keyword\">new</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">(</span>m1 equals<span class=\"token punctuation\">:</span> m2<span class=\"token punctuation\">)</span> ifTrue<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>  \n  Transcript show<span class=\"token punctuation\">:</span> <span class=\"token string\">'They are equal'</span>\n<span class=\"token punctuation\">]</span> else<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>  \n  Transcript show<span class=\"token punctuation\">:</span> <span class=\"token string\">'They are not equal'</span>\n<span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2>写在最后</h2>\n<p>本文介绍了 Smalltalk 中最为基础的语言规则与设计思想。在它出现的时候，它引领了面向对象、IDE 等等前沿的概念，而即使放到现在，它的语言特性也毫不过时。愿大家都能在了解 Smalltalk 的过程中有所收获。</p>","frontmatter":{"title":"Smalltalk 入门学习","date":"2017/10/05","tags":["Smalltalk"],"prompt":null},"fields":{"slug":"/smalltalk/","encrypted":null}}},"pageContext":{"id":"639914a2-751b-54d1-964d-1e8d1aac1ea4"}},"staticQueryHashes":["1633816651","3000541721","3000541721"]}