{"componentChunkName":"component---src-templates-post-js","path":"/p/javascript-metaprogramming/","result":{"data":{"markdownRemark":{"id":"f75d9285-e11c-5063-b29e-5f03ca68892f","excerpt":"最近阅读《Ruby 元编程》一书，拍案叫绝，又想到 JavaScript 语言和 Ruby 类似，相当灵活且具有一些元编程的特性，而且最近以及不久的将来都可能需要和 JavaScript 打交道，因此希望对照着这本书，探究些 JavaScript…","html":"<p>最近阅读《Ruby 元编程》一书，拍案叫绝，又想到 JavaScript 语言和 Ruby 类似，相当灵活且具有一些元编程的特性，而且最近以及不久的将来都可能需要和 JavaScript 打交道，因此希望对照着这本书，探究些 JavaScript 元编程的特性。</p>\n<!--more-->\n<h1>语言构件</h1>\n<p>元编程是对语言构件的操作，因此为了了解元编程，需要先了解它们语言构件的异同。</p>\n<p>在 Ruby 中，一切都是对象。一个对象则必然属于一个类。一个类是 <code class=\"language-text\">Class</code> 类的对象，而所有的类都是 <code class=\"language-text\">Object</code> 类的子类（严格来说是 <code class=\"language-text\">BasicObject</code>）。可以用一张图来展示：</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 690px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/80c1264b3ffa9bf98d891b9755130b6a/15ec7/meta1.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 46.30541871921182%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAJABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIDBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe3OwlQ//8QAGRAAAQUAAAAAAAAAAAAAAAAAAQIQITFB/9oACAEBAAEFAiYxNP8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFhABAQEAAAAAAAAAAAAAAAAAQQAg/9oACAEBAAY/Amc//8QAGRAAAwADAAAAAAAAAAAAAAAAAAEREDGR/9oACAEBAAE/IbMpwOA1XK0f/9oADAMBAAIAAwAAABCzD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABoQAQEAAgMAAAAAAAAAAAAAAAERACEgMVH/2gAIAQEAAT8QE4HqmIXCexpg7FhN8L//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"img\"\n        title=\"img\"\n        src=\"/static/80c1264b3ffa9bf98d891b9755130b6a/15ec7/meta1.jpg\"\n        srcset=\"/static/80c1264b3ffa9bf98d891b9755130b6a/efcb5/meta1.jpg 203w,\n/static/80c1264b3ffa9bf98d891b9755130b6a/02e66/meta1.jpg 405w,\n/static/80c1264b3ffa9bf98d891b9755130b6a/15ec7/meta1.jpg 690w\"\n        sizes=\"(max-width: 690px) 100vw, 690px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>在 JavaScript 中，一切依然是对象。但是它并不是基于类和继承构建的，而是基于独特的原型机制。JavaScript 的对象分为普通对象和函数。而函数除了普通调用以外，还可以通过 <code class=\"language-text\">new</code> 关键字调用，生成一个新的对象，而此时这个函数被称为构造函数。从形式上看，就像 Java 之类的用法。而每一个函数都会有一个 <code class=\"language-text\">prototype</code> 属性（除 <code class=\"language-text\">Function.prototype</code>），每一个对象都会有 <code class=\"language-text\">__proto__</code>  属性指向它的 <code class=\"language-text\">prototype</code> 。当访问一个对象的属性时，先在这个对象自身上找，若没有则在 <code class=\"language-text\">__proto__</code> 属性上寻找。这就是字面上“原型机制”的意义，即通过同一个构造函数构造的对象，都会表现得像这个构造函数的原型。</p>\n<p>JavaScript 的原型机制很有趣但令人费解。这里也只是蜻蜓点水，详细的解释可以参考网上的各种文章和知乎问答。只是随着 JavaScript 的用途越发广泛，对于适应了主流语言的程序员来说，很难利用它的原型机制构建起可靠的大规模应用，因此不停地有各种将 JavaScript 类化的方案。一种比较常规的做法是，将构造函数作为类，对于各个对象的属性，定义在对象自身上；而对于各个对象共享的方法，定义在类的原型对象上。对于继承，由于类的原型对象也是一个普通的对象，将其 <code class=\"language-text\">__proto__</code> 属性指向父类的原型对象，就可以继承父类的方法了。（讲的比较简略，读者可以自己推演下。另外，这并不是完美的做法，关于 JS 的继承衍生出不下五六种方法，感兴趣可以自行搜索）</p>\n<p>面对程序员们的广泛需求，在最新的 es6 标准中引入了 class 语法糖，帮助程序员以他们熟悉的方式来编写代码。 class 的基本原理正是上述的方案（当然，总有各种细节上的注意点，具体请参考 es6 标准的解读）。模仿上面那张图可以得到：</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 690px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e5734b8d7a9c7f0452a451ed93ef1e15/15ec7/meta2.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 41.87192118226601%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAIABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdyAuD//xAAXEAEAAwAAAAAAAAAAAAAAAAAAAREh/9oACAEBAAEFArah/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGRAAAQUAAAAAAAAAAAAAAAAAAAEQITGh/9oACAEBAAY/AqUjW//EABgQAQEBAQEAAAAAAAAAAAAAAAEAIREx/9oACAEBAAE/IXoY8UlNNv/aAAwDAQACAAMAAAAQ8A//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAaEAEAAwEBAQAAAAAAAAAAAAABABExIWHw/9oACAEBAAE/EDM040dhQocxfdh1q8T/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"img\"\n        title=\"img\"\n        src=\"/static/e5734b8d7a9c7f0452a451ed93ef1e15/15ec7/meta2.jpg\"\n        srcset=\"/static/e5734b8d7a9c7f0452a451ed93ef1e15/efcb5/meta2.jpg 203w,\n/static/e5734b8d7a9c7f0452a451ed93ef1e15/02e66/meta2.jpg 405w,\n/static/e5734b8d7a9c7f0452a451ed93ef1e15/15ec7/meta2.jpg 690w\"\n        sizes=\"(max-width: 690px) 100vw, 690px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>首先 JavaScript 中并没有和 Ruby 意义类似的 Module。其次，Function 在很大程度上类似其他语言的 Class 概念。再次，我没有在图中列出 superclass 关系。如果按照 es6 的 extends 关键字，那么 superclass 一定指代正确的父类，而对于图中这三个顶层的类，若按照上文的逻辑来分析，则会显得有些奇怪。</p>\n<p>姑且称图中的 <code class=\"language-text\">Object</code>、<code class=\"language-text\">Function</code>、<code class=\"language-text\">MyClass</code> 是顶层类。按照上文逻辑分析它们的 superclass，则都指向 <code class=\"language-text\">Function.prototype</code>，这是一个函数对象。而它的 superclass 指向 <code class=\"language-text\">Object.prototype</code>，这是一个普通对象。尽管一个普通对象不再是一个类了，但你仍然可以找到它的 <code class=\"language-text\">__proto__</code> 属性指向 null。在网上也能找到继承这三个奇怪的东西的分析。扯得有点远了。由于我们希望对程序员隐藏 JavaScript 的原型机制，我个人并不希望将 <code class=\"language-text\">Function.prototype</code> 视作所有类的父类。尽管如此，你依然可以在 <code class=\"language-text\">Function.prototype</code> 中定义所有函数对象可以访问的属性/方法，在 <code class=\"language-text\">Object.prototype</code> 中定义所有对象可以访问的属性/方法。</p>\n<h1>元编程</h1>\n<p>在上文中，我们实际上已经完成了第一步：将 JavaScript 类化。接下来，不妨按照《Ruby 元编程》中所列出的各种“法术”，寻求在 JavaScript 中的实现方法。</p>\n<h2>内省</h2>\n<p>内省使对象可以在运行时查询关于自己的一些信息，例如对象的类，类的父类，对象拥有哪些属性和方法等等。我们知道 JavaScript 中的类就是一个对象的构造函数，正好 JavaScript 提供了 <code class=\"language-text\">obj.constructor</code> 属性来查询对象的构造函数。得到父类同样简单，根据继承的原理，一个类的父类正是这个类的原型的原型所在的类，即 <code class=\"language-text\">class.prototype.__proto__.constuctor</code> 。</p>\n<p>至于对象身上的属性和方法， es6 提供了 Reflect 类来查询，其中很多方法来自于原先的 Object 类。将类命名为 Reflect 更好地体现了“反射”这一意图。</p>\n<h2>动态派发</h2>\n<p>调用一个对象的方法，实际上是向这个对象发送一条消息。基于这个思想，Ruby 中可以使用 <code class=\"language-text\">obj.send(&quot;method_name&quot;, args)</code>，动态地调用一个方法。方法名可以使用字符串拼装出来，因此大大提高了代码的灵活性。而在 JavaScript 中，方法不过是对象的一个函数属性，而属性本身也可以用字符串表示，也就是说，动态派发在 JavaScript 的设计中，并不是什么高级的用法，仅仅是一种再自然不过的语言特性罢了。在 Javascript 中上述代码等价于 <code class=\"language-text\">obj[&quot;method_name&quot;]()</code>。</p>\n<p>作用域绑定、define/delete、eval 和 new Function</p>\n<p>不能做的要素：类宏</p>\n<p>proxy能做的：methodmissing</p>\n<h1>一些感想</h1>","frontmatter":{"title":"JavaScript 元编程","date":"2017/06/30","tags":["Ruby","JavaScript","Metaprogramming"],"prompt":null},"fields":{"slug":"/javascript-metaprogramming/","encrypted":null}}},"pageContext":{"id":"f75d9285-e11c-5063-b29e-5f03ca68892f"}},"staticQueryHashes":["1633816651","3000541721","3000541721"]}