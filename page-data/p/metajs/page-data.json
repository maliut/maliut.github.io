{"componentChunkName":"component---src-templates-post-js","path":"/p/metajs/","result":{"data":{"markdownRemark":{"id":"5b4fd311-3668-5ec6-9005-c96209e228ee","excerpt":"meta.js 为 Javascript 语言扩充了一些元编程功能，在使用 ES6 的 class 语法定义类时，你能够以更加直观自然的方式，像一门原生就是基于类的语言那样，使用这些元编程功能。 可以在这里获取它的使用文档与源代码。 开发这个库的灵感来源于之前阅读的《Ruby 元编程》一书。考虑到 JavaScript…","html":"<p>meta.js 为 Javascript 语言扩充了一些元编程功能，在使用 ES6 的 class 语法定义类时，你能够以更加直观自然的方式，像一门原生就是基于类的语言那样，使用这些元编程功能。</p>\n<!--more-->\n<p>可以<a href=\"https://github.com/maliut/meta.js\">在这里</a>获取它的使用文档与源代码。</p>\n<br>\n<p>开发这个库的灵感来源于之前阅读的《Ruby 元编程》一书。考虑到 JavaScript 语言与 Ruby 同为动态语言，灵活度相似（具体的读后感与对比可以参考<a href=\"/p/javascript-metaprogramming\">这篇文章</a>），且在 JavaScript 开发中也会经常遇到一些需要语言动态性的场景以简化代码。而在 JavaScript 中操作这些动态性，就免不了与 prototype 打交道，而在最新的 ES6 语言规范中，class 等语法糖的引入，也表明了这门语言希望尽量淡化 prototype 之类的概念，降低新手的学习门槛与熟悉了其他语言的开发者们的知识迁移成本。故在这基础之上，我的元编程库也把这些细节封装起来，以便大家能用更自然的方式使用这些元编程功能。</p>\n<p>开发这个库的另一个动机则是对于 <code class=\"language-text\">method_missing</code> 在 JavaScript 中的实现。<code class=\"language-text\">method_missing</code> 是讲解 Ruby 语言动态性的一个典型例子，在实际开发中也不乏实用性。JavaScript 在 ES6 中引入了 Proxy，使得实现 <code class=\"language-text\">method_missing</code> 功能也成为了可能。但遗憾的是，网上所有讲解“如何在 JavaScript 中实现 <code class=\"language-text\">method_missing</code>” 的文章全是有问题的。它们只是简单演示了一下对 Proxy 的使用，却丝毫没有真正去使用过它。所以我在这个库中尽量严谨地实现了这个功能，以供大家参考。</p>\n<p>代码本身不长，也很简单，欢迎大家多多使用反馈。</p>","frontmatter":{"title":"meta.js - JavaScript 元编程工具库","date":"2017/11/24","tags":["JavaScript","Metaprogramming"],"prompt":null},"fields":{"slug":"/metajs/","encrypted":null}}},"pageContext":{"id":"5b4fd311-3668-5ec6-9005-c96209e228ee"}},"staticQueryHashes":["1633816651","3000541721","3000541721"]}