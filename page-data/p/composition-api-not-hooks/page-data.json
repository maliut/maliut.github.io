{"componentChunkName":"component---src-templates-post-js","path":"/p/composition-api-not-hooks/","result":{"data":{"markdownRemark":{"id":"8898889b-48a0-5d41-abb5-e2e699b1622f","excerpt":"在网上能看到很多人在谈论 Vue 的组合式 API（Composition API）与 React Hooks 时，将两者一起拿来比较，并认为随着这两者的推出，React 和 Vue 变得越来越像。诚然，Vue 的组合式 API 在设计之初受到过 React Hooks…","html":"<p>在网上能看到很多人在谈论 Vue 的组合式 API（Composition API）与 React Hooks 时，将两者一起拿来比较，并认为随着这两者的推出，React 和 Vue 变得越来越像。诚然，Vue 的组合式 API 在设计之初受到过 React Hooks 的启发，且这两者都可以把逻辑抽象成 function 来实现逻辑的内聚与复用，在视觉上有相似之处。不过本质上这两者的心智模型还是大不相同的，如果将它们混为一谈，不但容易引发对两者的误解，更可能（基于这份误解）造成写出来的代码中含有不易察觉的 bug。</p>\n<h2>组合式 API 的动机与实现</h2>\n<p>组合式 API 的效果用下面这张图片就可以清楚地表示出来：</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 810px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c265669334b87d3acf6a783bebdd6fbb/c1b63/1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsTAAALEwEAmpwYAAACHUlEQVQ4y6WS63LaMBCF+/5v1GnaQrhjbnYCSXCgDRAb34SNrYsla7cmtJDJqD861WjW1mo+7dkjfcL/GJ8ufwnJYpKR9Jgdi4ikl3y93AcxIVlS7x1pnKR15iOc55TmBS+o5IJRBn/yjIuUslyUxzovFeWCi/IjrCsd+sEhSUgUC8av4gC0H4DnYxiepqoMsrVU6WLBVi5znxQhZ+xtQ4veULV60B/CwELGDHCl1H6zTPxnsnd5cYVBw3LKHiy+nAh3VpYcDLAAPazyEdL6cB/VCfutGqdDaXW1PUJnjIKb3C6ldlb8cavmL1Wc6YvqOtqWGPcqZwR3YzDDsoRxW9oDmHYgfMX3sGOVo562LXD+DuOwo8d9tLq4/wiLUVfZlnbG2gwrqd1ZvL4/rBySRvyd2TizTodOhji1kBth1CVbN8TPJrw2Id9e3QbYLrzN3POeAn8ZqrIyw3zbpi+32m8D3Z2dPsdy12XrG/BbGHSw4ibZlX78kbjbw/M2TXNxkV1/q92Auzew66DfR8WNV4WDiZ44MLIxiK6G1a+ERIs4nB2Su4zMdVWaXpjUm4fUWxWemxepvBqG0ODks0q/w7GJOUVt6plr/JZgM8NGjq/y0jKgbsXOVzJpFXa7uGNgrqw207U33/jzDU3ys8+nyqCb0eALaTey/m02YNrUswRlHe6n9GHCF5EibzXhHEOZ7GUUyDiUcQXGq/r38QtqyHwbuaxo4QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"组合式 API 与选项式 API 对比\"\n        title=\"组合式 API 与选项式 API 对比\"\n        src=\"/static/c265669334b87d3acf6a783bebdd6fbb/d7542/1.png\"\n        srcset=\"/static/c265669334b87d3acf6a783bebdd6fbb/2efce/1.png 203w,\n/static/c265669334b87d3acf6a783bebdd6fbb/1d180/1.png 405w,\n/static/c265669334b87d3acf6a783bebdd6fbb/d7542/1.png 810w,\n/static/c265669334b87d3acf6a783bebdd6fbb/c1b63/1.png 1200w\"\n        sizes=\"(max-width: 810px) 100vw, 810px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>在传统的选项式 API 中，组件为我们提供了一组 Object 形式的配置对象。我们可以将响应式变量定义在 <code class=\"language-text\">data</code> 字段，监听逻辑定义在 <code class=\"language-text\">watch</code> 字段，各个生命周期想做的事情定义在诸如 <code class=\"language-text\">mounted</code> 等生命周期字段中。</p>\n<p>但真实世界中的一个组件往往由复杂的逻辑交织而成，在组合式 API 中，我们只能把同一逻辑关注点的代码分散到各个字段中。例如开始监听和取消监听同一事物就得分别放在 <code class=\"language-text\">mounted</code> 和 <code class=\"language-text\">beforeDestroy</code> 中。随着组件体积的膨胀，这些代码逻辑所在的位置愈发割裂，使得开发者在阅读理解代码时愈发困难。</p>\n<p>为了解决这个问题，组合式 API 就应运而生了。在组合式 API 中，我们不再要求业务代码把自己的逻辑分门别类地放置在配置对象中，而是利用依赖倒置的思想，将配置对象的各个字段变为钩子函数（例如 <code class=\"language-text\">mounted: someFunc</code> → <code class=\"language-text\">onMounted(someFunc)</code> ），提供给业务代码，使业务代码能够将自己<em>钩入</em> 组件的生命周期等逻辑中。这样，相同逻辑关注点的代码就可以被放在一起，从而提高了代码的内聚性。</p>\n<p>一段典型的组合式 API 代码如下所示（来自官网的例子）：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token function\">setup</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> repositories <span class=\"token operator\">=</span> <span class=\"token function\">ref</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">getUserRepositories</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    repositories<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token operator\">...</span> <span class=\"token comment\">// fetch repositories</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">onMounted</span><span class=\"token punctuation\">(</span>getUserRepositories<span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\">// 在 user prop 的响应式引用上设置一个侦听器</span>\n  <span class=\"token function\">watch</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">,</span> getUserRepositories<span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    repositories<span class=\"token punctuation\">,</span>\n    getUserRepositories\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>与它等价的选项式 API 则是：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">data</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n      repositories<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  watch<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    user<span class=\"token operator\">:</span> <span class=\"token string\">'getUserRepositories'</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  methods<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">getUserRepositories</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>repositories <span class=\"token operator\">=</span> <span class=\"token operator\">...</span> <span class=\"token comment\">// fetch repositories</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">mounted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">getUserRepositories</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>组合式 API 带来的另一个好处是，这样的写法可以使一段逻辑天然地放到一段函数当中，从而实现逻辑的细粒度复用。在选项式 API 中，虽然可以通过 mixin 的方式实现一定的复用，但存在着变量名冲突、难以处理逻辑之间的依赖关系等种种问题。而通过函数的方式进行逻辑复用，使这些问题迎刃而解，并且没有任何 magic，十分优雅。</p>\n<h2>Android Lifecycle API</h2>\n<p>与其说 Vue 的组合式 API 像 React Hooks，我觉得不如说它更像 Android 的 <a href=\"https://developer.android.com/topic/libraries/architecture/lifecycle?hl=zh-cn\">Lifecycle API</a> 。我挺惊讶居然没有人把这两者作对比。虽说 Android 原生并没有 Vue 核心的响应式数据概念（当然，已经有官方支持的 LiveData 与 DataBinding 这些了<del>更不用说 Jetpack Compose</del>，但这里不展开，不然就没完没了了），但 Android Lifecycle API 与 Vue 组合式 API 所要解决的问题 —— 即逻辑关注点分散、混乱的问题 —— 与解决手段，却是有着异曲同工之妙。</p>\n<p>在传统的 Android 应用开发中，不少逻辑都依赖于生命周期实现。Android 中拥有生命周期的单元是 Activity 和 Fragment ，其他的业务逻辑若是需要感知生命周期，就需要把它们的代码放到 Activity 和 Fragment 的各个生命周期中，这就导致了代码膨胀与逻辑关注点分离的问题。</p>\n<p>例如我们需要一个感知当前地理位置的功能，一般以如下形式实现：</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyActivity</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AppCompatActivity</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">MyLocationListener</span> myLocationListener<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onCreate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        myLocationListener <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyLocationListener</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>location<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">// update UI</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onStart</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">onStart</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        myLocationListener<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// manage other components that need to respond</span>\n        <span class=\"token comment\">// to the activity lifecycle</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onStop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">onStop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        myLocationListener<span class=\"token punctuation\">.</span><span class=\"token function\">stop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// manage other components that need to respond</span>\n        <span class=\"token comment\">// to the activity lifecycle</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>很明显，这样的做法与 Vue 的选项式 API 存在同样的逻辑割裂、组件膨胀等问题。Android 官方也逐渐意识到了这个问题。因此，在它们提供的新的架构组件中，推出了 Lifecycle API。它提供的解决方案我们也不难想到。我们把 Lifecycle 作为一个单独的概念抽象出来，使之不局限于 Activity 和 Fragment 中。而需要感知生命周期的业务逻辑，可以以回调函数的形式把这些逻辑<em>勾入</em> 相应的生命周期中。</p>\n<p>这样一来，和这个业务单元的所有相关代码都可以被放在一起，提高了内聚性，且保持了 Activity/Fragment 文件本身逻辑的清晰。另一方面，我们在使用这业务逻辑时也无需关心它究竟在 Activity 还是 Fragment 中，只要存在生命周期就好。这也提升了逻辑的可复用性。</p>\n<p>使用 Lifecycle API 实现的例子如下所示：</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyObserver</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">LifecycleObserver</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@OnLifecycleEvent</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Lifecycle</span><span class=\"token punctuation\">.</span><span class=\"token class-name\">Event</span><span class=\"token punctuation\">.</span>ON_RESUME<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">connectListener</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@OnLifecycleEvent</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Lifecycle</span><span class=\"token punctuation\">.</span><span class=\"token class-name\">Event</span><span class=\"token punctuation\">.</span>ON_PAUSE<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">disconnectListener</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\nmyLifecycleOwner<span class=\"token punctuation\">.</span><span class=\"token function\">getLifecycle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">addObserver</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">MyObserver</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>对比 Android 与 Vue ，可以看到它们所面临的问题，以及选择的解决方式，都是极为相似的。</p>\n<h2>那么 React Hooks 呢？</h2>\n<p>在 React Hooks 出现之前，我们编写有状态组件，只能使用类组件（Class Component）的形式，并在类组件的生命周期方法中编写相关的逻辑。明显，这和 Vue 与 Android 面临的问题是一样的。我们可以轻易地将上文展现的解决方式迁移到 React 中，为它设计一套新的 API：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyComponent</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 相当于 Vue 的 setup</span>\n  <span class=\"token function\">contructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// 把业务逻辑注册到生命周期中，以实现逻辑的内聚和可复用</span>\n    <span class=\"token function\">didMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">didUpdate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  \n  <span class=\"token comment\">// 相当于 Vue 的模板</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>很容易理解，不是么？可是 React 团队却不满意于此，而是交出了一份不一样的答卷。他们完全抛弃了类组件的写法，连带着抛弃了生命周期的概念。</p>\n<p>我们学习一项新技术时，会想怎么把旧的思维方式迁移过去。这不就有人会问：class 的生命周期方法是怎么对应到新的 hooks 上面的呢？于是搜索了一下发现 <code class=\"language-text\">useEffect</code>可以通过各种写法的组合来模拟原来的 <code class=\"language-text\">componentDidMount</code>、<code class=\"language-text\">componentDidUpdate</code> 与 <code class=\"language-text\">componentWillUnmount</code>，然后一边抱怨怎么起了个这么一个和原来的生命周期完全不像的名字，一边死记硬背各种组合的用法。</p>\n<p>那么为什么 React 团队放着前面简单的方式不做，而是采用这种看似如此绕的方式呢？其实 React Hooks 为我们带来的是一种新的思维方式，只是我们还拿旧的思路去理解它，所以觉得它比较绕。</p>\n<p>为了说明这个问题，我们还得从类组件说起。众所周知，React 采用了函数式编程的理念，通过不可变性来感知状态变更，从而触发 UI 更新。无状态的函数组件是纯函数，自然可以无限次数地调用。可对于有状态的类组件，每次渲染仅仅是调用它的 <code class=\"language-text\">render</code> 函数，这个组件类的实例在多次渲染之间仍然是同一个，因此在它身上定义的实例变量事实上成为了可变数据。这就使得类组件的工作方式在 React 理念中显得格格不入，成为引发各种不易察觉的 bug 的源头。</p>\n<p>可变数据的典型便是 <code class=\"language-text\">this.state</code>。虽然理论上我们必须通过 <code class=\"language-text\">setState</code>函数来修改 <code class=\"language-text\">this.state</code>，但这只是为了让 React 能够感知到变化并触发重新渲染。你也完全可以直接对 <code class=\"language-text\">this.state</code> 赋值，然后手动触发渲染，或是让别处触发的重新渲染使你的改变体现在 UI 上。</p>\n<p>这样的行为符合我们长久以来（习惯于面向对象）的认知，但有时会给我们带来麻烦，尤其是在有异步行为的场景中。React 核心开发者 Dan Abramov 在<a href=\"https://overreacted.io/zh-hans/how-are-function-components-different-from-classes/\">他的文章</a>中举了一个有代表性的例子。例如在社交网站中，我们可以点击关注一个人的社交帐号，向服务器请求回包后弹窗告知用户关注成功。</p>\n<div class=\"gatsby-highlight\" data-language=\"reactjsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-reactjsx line-numbers\"><code class=\"language-reactjsx\">class ProfilePage extends React.Component {\n  showMessage = () =&gt; {\n    alert(&#39;Followed &#39; + this.props.user);\n  };\n\n  handleClick = () =&gt; {\n    setTimeout(this.showMessage, 3000);\n  };\n\n  render() {\n    return &lt;button onClick={this.handleClick}&gt;Follow&lt;/button&gt;;\n  }\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这段代码存在着 bug，而 bug 的根源就在 <code class=\"language-text\">this.props</code> 的可变性上。假如我们在 A 的主页点击了关注，但在 3 秒中内切换到 B 的主页，由于 <code class=\"language-text\">this.props.user</code> 变成了 B，弹窗的内容就成了 “Followed B”。但如果我们使用函数组件，就可以天然规避这个问题：</p>\n<div class=\"gatsby-highlight\" data-language=\"reactjsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-reactjsx line-numbers\"><code class=\"language-reactjsx\">function ProfilePage(props) {\n  const showMessage = () =&gt; {\n    alert(&#39;Followed &#39; + props.user);\n  };\n\n  const handleClick = () =&gt; {\n    setTimeout(showMessage, 3000);\n  };\n\n  return (\n    &lt;button onClick={handleClick}&gt;Follow&lt;/button&gt;\n  );\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>没有 bug 是因为它只是一个普通的函数。当 <code class=\"language-text\">user</code> 改变时，React 传入新的 <code class=\"language-text\">props</code> 重新执行了这个函数，因此在当次函数执行过程中，所有地方读到的 <code class=\"language-text\">props</code> 都是同一个值，即当次渲染传入的值。而不是像类组件那样，改变了 <code class=\"language-text\">this.props</code> 的内容。以这个函数的视角来看，<code class=\"language-text\">props</code> 只是一个普通的对象值罢了，而不是某个实例变量的引用。</p>\n<p>理解了函数组件如何规避可变状态带来的问题，就可以理解为何要用 Hooks 取代类组件。通过 Hooks，我们可以让 state 也和 props 一样，获得在组件单次渲染中的不可变性。这也更加贯彻了 React 的函数式、不可变的理念。我们可以把上面的例子用 <code class=\"language-text\">useState</code> 来改写，一样是符合我们预期，没有 bug 的。</p>\n<div class=\"gatsby-highlight\" data-language=\"reactjsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-reactjsx line-numbers\"><code class=\"language-reactjsx\">function ProfilePage() {\n  const [user, setUser] = useState(&#39;A&#39;)\n  \n  const showMessage = () =&gt; {\n    alert(&#39;Followed &#39; + user);\n  };\n\n  const handleClick = () =&gt; {\n    setTimeout(showMessage, 3000);\n  };\n\n  return (\n    &lt;button onClick={handleClick}&gt;Follow&lt;/button&gt;\n  );\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>没有 bug 的原因是，<code class=\"language-text\">user</code> 变量在单次渲染时实际上就是一个普通的字符串（可以想象把所有的 <code class=\"language-text\">user</code> 都替换成 <code class=\"language-text\">&#39;A&#39;</code> ）。而倘若通过 <code class=\"language-text\">setUser</code> 改变了 <code class=\"language-text\">user</code> 值，也只是触发下一次对函数的调用，对当次渲染毫无影响。</p>\n<p>我们可以以 Vue 的视角审视下这个例子。如果你认为 Vue 的组合式 API 与 React Hooks 相当的话，我们可以用组合式 API 来实现这个例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-html line-numbers\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>template</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>select</span> <span class=\"token attr-name\">v-model</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>user<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>option</span><span class=\"token punctuation\">></span></span>A<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>option</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>option</span><span class=\"token punctuation\">></span></span>B<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>option</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>select</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">@click</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>handleClick<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>Follow<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>template</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">setup</span><span class=\"token punctuation\">></span></span><span class=\"token script\"><span class=\"token language-javascript\">\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> ref <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'vue'</span>\n\n<span class=\"token keyword\">const</span> user <span class=\"token operator\">=</span> <span class=\"token function\">ref</span><span class=\"token punctuation\">(</span><span class=\"token string\">'A'</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">showMessage</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Followed </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>user<span class=\"token punctuation\">.</span>value<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">handleClick</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>showMessage<span class=\"token punctuation\">,</span> <span class=\"token number\">3000</span><span class=\"token punctuation\">)</span>\n</span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>不难看出这段代码和 React 的类组件实现一样，是存在 bug 的版本（当然，用选项式 API 也一样）。但是对于 Vue 来说这样的结果是符合预期的。因为不像 React 遵循的不可变性理念，Vue 采用的是响应式数据的理念，数据是可变的，这必然要求我们持有响应式数据的引用。</p>\n<p>事实上想要使用 React Hooks 完美还原这段 Vue 代码的能力，我们也要采取类似的做法，通过 <code class=\"language-text\">useRef</code> Hook 为 <code class=\"language-text\">user</code> 变量创建一个可以横跨多次渲染的引用。而想要在 Vue 中规避这个 bug，并没有完全对应 React 函数组件的做法，只能另想办法规避了。</p>\n<h2>useEffect 与 watch</h2>\n<p>React 的 <code class=\"language-text\">useEffect</code> hook 与 Vue 组合式 API 的 <code class=\"language-text\">watch</code> 方法是一组经常被拿出来比较的概念。它们做的事情类似，都是在各自的依赖发生改变时，执行对应的逻辑。但光看它们的名字却是大不相同。但如果我们了解了 React Hooks 与 Vue 组合式 API 各自的理念和动机，就不难理解它们的不同之处。</p>\n<p>Vue 的 <code class=\"language-text\">watch</code> API 很容易理解，它对应于原来选项式 API 中的 <code class=\"language-text\">watch</code> 选项。顾名思义，就是监听数据的变更。由于 Vue 基于响应式数据的理念，能够跟踪所有响应式变量的变更，因此能做到这些并不费吹灰之力。</p>\n<p>而对于 React 的 <code class=\"language-text\">useEffect</code> hook，上文已经提到，我们不要再用生命周期的思想去类比它，而是从函数式的角度去理解。在理想的情况下 ，所有渲染函数都是纯函数，这样我们可以放心地无限次调用它们。但是现实显然没有这么美好，除了渲染之外往往还要做些别的事情。React 统一把这些事情认为是副作用（Side Effect），这也就是函数名 <code class=\"language-text\">useEffect</code> 的来历。</p>\n<p>既然是渲染的副作用，那它自然是在每次渲染之后都会调用一次。至于它的依赖数组，只是用来规避重复调用副作用时可能带来的性能、死循环等问题。在 React 看来，依赖数组只是一个普通的数组，和副作用函数中的内容毫无关系。这也是为什么 React 不会为我们自动收集依赖。如果你愿意，你完全可以通过自己编排依赖数组来达到自己的目的。只是大多数时候人脑应付不过来过于复杂的逻辑，因此官方推荐我们诚实地把依赖数组的内容与副作用函数的真正依赖保持一致。</p>\n<p>所以 <code class=\"language-text\">useEffect</code> 和 <code class=\"language-text\">watch</code> 这两者在设计意图上就完全不同，只是最终殊途同归而已。网上很多文章在对比组合式 API 与 React Hooks 时只会轻描淡写地提到一句“前者只执行一次，后者会执行多次”，却没有意识到这一区别的背后隐藏着它们设计理念上的巨大差别。</p>\n<h2>结语</h2>\n<p>在对比了 Vue 组合式 API 与 React Hooks 之后，我们发现它们并不是像看上去那样变得逐渐相似，恰恰相反，它们进一步把自己的特点推向了极致。Vue 通过组合式 API 进一步暴露了它的响应式数据能力，使之不再局限于 Vue 实例以内，更便于逻辑组合与复用。而 React 通过 Hooks 弥补了 class 组件中可变数据的隐含问题，进一步贯彻了函数式编程、不可变数据的设计理念。它们实际上变得越来越不同了。</p>\n<p>而对于我们使用者来说，在使用一项技术前需要让自己充分理解这一技术的设计理念，顺着它的思路来写代码。当然，这需要花点时间去学习和适应新的概念，尤其是对于 React Hooks。顺着它们的心智模型去写代码，才能事半功倍。而不是想当然地把旧的经验套用在新技术上，等出了问题再高呼真坑。</p>","frontmatter":{"title":"组合式 API 不是 Hooks！","date":"2021/08/14","tags":["Vue","React"],"prompt":null},"fields":{"slug":"/composition-api-not-hooks/","encrypted":null}}},"pageContext":{"id":"8898889b-48a0-5d41-abb5-e2e699b1622f"}},"staticQueryHashes":["1633816651","3000541721","3000541721"]}