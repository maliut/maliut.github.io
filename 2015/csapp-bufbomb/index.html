<!DOCTYPE html>
<html lang="zh">
    <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <!--<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">-->
    
    <title>CSAPP:Bufbomb | Mの综合研究</title>
    <link href="https://cdn.bootcss.com/normalize/8.0.0/normalize.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/css/style.css">
</head>
    <body>
      
<header role="banner" id="site-banner" class="unselectable center ">
    
        <a id="site-logo" href="/"><span class="site-logo-large">Mの</span><br /><span>综合研究</span></a>
    
    <nav role="navigation" id="site-nav">
        <ul>
        
            <li><a href="/categories/proj" class="intent3"><i class="icon-folder"></i>&nbsp;项目</a></li>
        
            <li><a href="/categories/tech" class=""><i class="icon-cog"></i>&nbsp;技术</a></li>
        
            <li><a href="/categories/life" class=""><i class="icon-heart"></i>&nbsp;生活</a></li>
        
            <li><a href="/idea" class=""><i class="icon-hangouts"></i>&nbsp;想法</a></li>
        
            <li><a href="/about" class=""><i class="icon-user"></i>&nbsp;关于</a></li>
              
        </ul>
    </nav>
</header>
      <main role="main" class="center">
        
<article class="post">
    <h1 class="">CSAPP:Bufbomb</h1>
    <time class="">2015/08/01</time>
    <section><blockquote>
<p>from wordpress, 放 tietuku 的图都挂光了</p>
</blockquote>
<p>关于 CSAPP 的各个经典的 Lab ，网上的解答已是一搜一大堆。本文的目的是记录自己亲身做完后的一些感悟，不过多探讨具体的做法，而是归纳一些平时看书不太注意的，而需要在 Lab 里理解透彻的地方，和做 Lab 时需要默认知道的一些信息和经验，以便少走弯路。在此基础上略谈各题做法。</p>
<a id="more"></a>
<p>我的解题主要参考了<a href="http://blog.sina.com.cn/s/blog_65eb367a0101exfa.html" target="_blank" rel="noopener">这篇文章</a>，尽管网上有许多解答，但这篇图文并茂的博文给我带来的帮助显然是最大的，此外还有<a href="http://blog.youlingman.info/csapp-bufbomb-lab-solve/" target="_blank" rel="noopener">这篇文章</a>，通过对比两篇文章，我才能更好理解最后一题。在此表示感谢。</p>
<p>在我看来，这个 Lab 的主要目的在于，使你对栈帧的结构、调用过程中的寄存器变化（<code>%esp</code>,<code>%ebp</code>,<code>%eax</code>）有更加深刻的了解。在这个 Lab 里你必须要对 <code>leave</code> 和 <code>ret</code> 指令的具体操作有了解，而不能仅仅像上一个 Lab:Binarybomb 那样，仅仅将它们抽象为回到调用过程前的状态。因为通过缓冲区溢出，你已经破坏了原来的栈帧结构。</p>
<p>关于解题，你需要知道的一些知识：</p>
<ol>
<li><p>栈帧结构</p>
<p>当调用一个过程后，栈帧结构如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">传入参数2</span><br><span class="line">传入参数1</span><br><span class="line">返回地址</span><br><span class="line">旧的 %ebp</span><br><span class="line">......</span><br><span class="line">栈顶</span><br></pre></td></tr></table></figure>
<p>其中 <code>%ebp</code> 指向旧的 <code>%ebp</code> ， <code>%esp</code> 指向栈顶</p>
</li>
<li><p>本 Lab 中输入字符串的保存位置和合法的字符串最大长度</p>
<p><code>getbuf</code> 函数的代码如下（图挂）</p>
<p>其中调用了 <code>Gets</code> 读取输入，但这个大概和系统函数差不多，就不深究了。观察之前系统为这个函数分配了 0x38 的空间，但这并不代表字符串允许长度为 0x38 。下一行的 <code>lea</code> 指令计算了 <code>%ebp-0x28</code> 的值。这里先验地说明，这个值，即旧的 <code>%ebp</code> 往下 0x28 的空间里，才是存储字符串的地方。如果字符串超出了这个限制，则会继续向上覆盖旧的 <code>%ebp</code> ，返回地址，etc。<br>同时这也说明真正合法字符串的长度并不是 PDF 给的代码中规定的值。 0x28 即十进制 40 说明最多 40 个字节，那么 41-44 字节就覆盖了旧的 <code>%ebp</code> ， 45-48 字节覆盖了返回地址。最后一题的 <code>getbufn</code> 也是同理（开始做的时候直接以为是 512 但其实是 520 所以被坑死）。<br>那么如何查看输入的字符串？以使用 GDB 为例，在 <code>0x804940d</code> 设下断点，在此处可以查看 <code>%ebp</code> 的值，其减去 0x28 即字符串的起始地址。也可直接查看 <code>%eax</code> ，先验认为从 <code>Get</code> 返回后， <code>%eax</code> 即保存了返回值的地址。查看时要注意代码为<code>p (char *) %eax</code>，因为 <code>%eax</code> 的值已经是字符串的地址，不能再在 <code>%eax</code> 前加 <code>*</code> 。</p>
</li>
<li><p><code>leave</code> 和 <code>ret</code> 指令</p>
<p><code>ret</code> 指令前必须要 <code>leave</code> ，否则无法完全恢复调用前的状态，但也可以自己手动模拟这两个指令的效果。<br><code>leave</code> 指令等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movl %ebp, %esp  # %esp 指向 %ebp 指向的位置，即旧的 %ebp</span><br><span class="line">                 # 由于 %esp 就是栈顶指针， pop 和 push 都相对与这个操作，</span><br><span class="line">                 # 所以相当于 %esp 下面的东西都没了</span><br><span class="line">popl %ebp        # 注意 %esp 指向旧的 %ebp ，所以将 %ebp 恢复为旧的 %ebp</span><br><span class="line">                 # 同时 %esp+4，指向返回地址</span><br></pre></td></tr></table></figure>
<p><code>ret</code> 指令的效果为从栈中弹出一个地址，并跳转到这个地址<br>因为此时 <code>%esp</code> 指向返回地址，因此程序跳转到返回地址，此时 <code>%esp</code> 继续 +4 ，指向返回地址的上一个</p>
<p>利用 <code>ret</code> 的性质，本 Lab 中后几题都要用到一个技巧，在这些题中我们要自己输入汇编代码，再修改 <code>getbuf</code> 的返回地址，让程序执行我们输入的代码，然后再 <code>ret</code> 到别的函数中。但先让程序跳转到我们输入的地方已经使栈帧结构荡然无存，如何再让其 <code>ret</code> 到一个特定位置？使用如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push $0xabcdefg</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>这段代码使程序 <code>ret</code> 到地址 <code>0xabcdefg</code> 处。知道了 <code>ret</code> 的具体效果，应该不难理解它的原理。</p>
</li>
<li><p>小端法</p>
<p>这只是一个小提醒了，直接输入地址作为 char 时要反一下，但如果是通过反编译生成的 char 就不用了，因为编译时系统已自动生成。看一下反编译出来的 asm 文件就能明白。</p>
</li>
</ol>
<p>下面开始题目相关：</p>
<h1 id="Level-0：Candle"><a href="#Level-0：Candle" class="headerlink" title="Level 0：Candle"></a>Level 0：Candle</h1><p>要求执行完 <code>getbuf</code> 后跳转到 <code>smoke</code> 中，只要覆盖掉返回地址就可以，把原来的返回地址改为 <code>smoke</code> 函数的起始地址，本机上是 <code>0x08048c8c</code> ，这样答案可写成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">8c 8c 04 08</span><br></pre></td></tr></table></figure></p>
<p>前面 40 个是正常存储的字节，后 4 个是旧的 <code>%ebp</code> 区域，最后 4 个就是返回地址。前面 00 只要是除了 <code>’n’</code> 任意均可，最后写成 <code>smoke</code> 起始地址的反序。</p>
<h1 id="Level-1：-Sparkler"><a href="#Level-1：-Sparkler" class="headerlink" title="Level 1： Sparkler"></a>Level 1： Sparkler</h1><p>跳转到 <code>fizz</code> 中，但是这时要把你的 cookie 作为参数传进去。第一感觉参数放在返回地址上面，但实际上却不是。 <code>ret</code> 完事后 <code>%esp</code> 指向返回地址上面一个地址，然后执行 <code>fizz</code> 时，先 push 了 <code>%ebp</code> ，此时 <code>%esp-4</code>  ，即原来保存返回地址的地方，然后 <code>mov</code> 指令将 <code>%ebp</code> 也指向 <code>%esp</code> 指向的地方，再取了 <code>%ebp+8</code> 指向的值作为参数，所以参数应该保存在这个位置，即返回地址向上 2 格的位置处！</p>
<p>（图挂）</p>
<p>至于为什么和常识不一样，是因为我们篡改了 <code>getbuf</code> 的返回地址运行 <code>fizz</code> ，而没有 call <code>fizz</code> ，因此没有另保存一个返回地址，导致了偏差。</p>
<p>答案与上题类似，不专门给出，可以自行推算或查看我开头给的两个别人的博客。</p>
<h1 id="Level-2：-Firecracker"><a href="#Level-2：-Firecracker" class="headerlink" title="Level 2： Firecracker"></a>Level 2： Firecracker</h1><p>跳转到 <code>bang</code> 中，但是需要更改一个全局变量。先验地知道全局变量存在程序中一个固定的地址处。</p>
<p>查看 <code>bang</code> 中比较两数的代码：</p>
<p>（图挂）</p>
<p>不难发现 <code>0x804d2a0</code> 和 <code>0x804d298</code> 中存着全局变量和 cookie ，通过 GDB 调试进一步确定各自保存的东西（我在图中已经标出，另，据说也可通过 <code>objdump -D</code> 查看，此处不提）。知道了全局变量的保存地址，接下来就是自己构造代码了。思路如下：让代码以字符串的形式输入，然后修改 <code>getbuf</code> 的返回地址为保存的字符串的起始位置，使程序执行这些代码，然后 <code>ret</code> 到 <code>bang</code> 中。我们需要手写汇编代码，然后使用 gcc 编译后再利用 objdump 反编译得到对应的 char 。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl $0xcookie, 0x804d2a0   # 把你的 cookie 放入全局变量，不用反序</span><br><span class="line">push $0x8048d08             # 让这段代码执行完后返回 bang 函数</span><br><span class="line">ret                         # 如果看不懂，复习本文之前的内容</span><br></pre></td></tr></table></figure>
<p>反编译得到 char 后任意填充到 40 字节，再任意 4 字节覆盖旧的 <code>%ebp</code> ，最后 4 字节写为保存字符串的起始地址即可。具体的就不再给出了。</p>
<h1 id="Level-3：Dynamite"><a href="#Level-3：Dynamite" class="headerlink" title="Level 3：Dynamite"></a>Level 3：Dynamite</h1><p>需要使 <code>getbuf</code> 返回 cookie 而不是 1 。返回值保存在 <code>%eax</code> 中，只需要使 <code>getbuf</code> 先返回到我们输入的代码处，替换掉 <code>%eax</code> 后再返回原来的 <code>test</code> 中即可。但是我们想让电脑以为什么错误都没发生，而之前的代码都把旧的 <code>%ebp</code> 覆盖掉了，这次不能覆盖它。（可以手工推一下，因为之前都是跳转到别的函数然后退出程序，这次返回到 <code>test</code> 中，而 <code>test</code> 是 <code>getbuf</code> 真正的调用者，返回后 <code>%ebp</code> 要读自己指向的内容即旧的 <code>%ebp</code> 才能恢复 <code>test</code> 的栈帧，若被覆盖则不能还原）<br>因此这题的答案要注意两点。一是手工编写的汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl $0xcookie, %eax  # 把 %eax 改为你的cookie</span><br><span class="line">push $0x8048d75       # 返回地址设为 test 中 call&lt;getbuf&gt; 的下一条，即正常状态下的返回地址</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>二是要先用 GDB 调试读出旧的 <code>%ebp</code> 的值，其地址即为此刻 <code>%ebp</code> 的值。然后要用这个值反序写在答案中覆盖旧的 <code>%ebp</code> 的部分。</p>
<h1 id="Level-4：Nitroglycerin"><a href="#Level-4：Nitroglycerin" class="headerlink" title="Level 4：Nitroglycerin"></a>Level 4：Nitroglycerin</h1><p>运行一次程序，会提示你输入 5 次字符串，要求每次的字符串都要相等，但 5 次字符串保存的位置不一样。其余要求同上一题。同样面临两个问题。一是无法得知 <code>getbufn</code> 的返回地址应该设在哪里，因不知道每次字符串的保存位置。解决方法是用 <code>nop</code> 指令，至于为什么，可以参考文首给出的两篇博客，我虽可理解但也未必讲得出所以然。只想说注意跳转的位置指向 5 次随机数的最高处。这个静下心来想一想可以想清楚。还有就是不知道 <code>%ebp</code> 要恢复成哪一个值，解决方法是依靠其与 <code>%esp</code> 的数量关系，那两篇博客也讲得很好了，此处不提。</p>
</section>
    <section class="">
        <small>
        TAGS:&nbsp;
            <a class="tag-link" href="/tags/CSAPP/">CSAPP</a>
        
        </small>
    </section>
</article>

    <div id="vcomments"></div>
    <script src="//cdn1.lncld.net/static/js/3.7.3/av-min.js"></script>
    <script src="/Valine.min.js"></script>
    <script type="text/javascript">
        new Valine({
            el: '#vcomments',
            notify: true,
            verify: false,
            app_id: "KNr19IGaxOxhyEPC2OXwmlbK-gzGzoHsz",
            app_key: "6FKxDyP2jMSYNYCKbk71eevC",
            placeholder: "Say something...",
            avatar: 'retro',
            submail_appid: "13112",
            submail_appkey: "e66bb0bad3a54056d660664b3f044ff5",
            submail_template: "e1BUq2",
            post_title: "CSAPP:Bufbomb"
        });
    </script>

      </main>
    </body>
    <footer role="contentinfo" class="center">
    <div id="site-links">
        <a href="/archives"><i class="icon-database" style="font-size: 15px"></i></a>
        <a href="mailto:lqn619@163.com" target="_blank" rel="external"><i class="icon-at"></i></a>
        <a href="https://github.com/maliut" target="_blank" rel="external"><i class="icon-github"></i></a>
        <a href="https://weibo.com/maliut" target="_blank" rel="external"><i class="icon-sina-weibo"></i></a>
        <a href="https://steamcommunity.com/id/maliut" target="_blank" rel="external"><i class="icon-steam"></i></a>
    </div>
    <p id="copyright">2020&nbsp;&copy;&nbsp;<a href="/">Mの综合研究</a>&nbsp;|&nbsp;Theme <a href="https://github.com/maliut/hexo-theme-simpow" title="SimPow" target="_blank" rel="noopener">SimPow</a></p>
</footer>
<script>
    console.log('Welcome!\nTheme SimPow inspired by Typescript & orzfly.com');
</script>
</html>